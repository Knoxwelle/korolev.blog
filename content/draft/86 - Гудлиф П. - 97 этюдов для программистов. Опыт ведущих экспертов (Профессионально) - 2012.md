+++
title='Числа с плавающей запятой недействительны'
date=2024-07-10T00:00:00-07:00
draft=true
categories=[]
tags=[]
cover_image='/images/cover/knoxwelle__2021-08-08T051054.000Z.jpg'
+++
Чак Эллисон
Чис­ла с пла­ваю­щей за­пя­той не яв­ля­ют­ся «дей­ст­ви­тель­ны­ми чис­ла­ми» в математическом смысле, хотя в некоторых языках программирования, например 
в Pascal и Fortran, носят название таковых (real). Действительные числа имеют 
бесконечную точность, и потому они непрерывны и не подвержены искажениям. 
Числа с плавающей запятой имеют ограниченную точность, а потому конечны 
и похожи на «непослушные» целые, так как неравномерно распределены по всему своему диапазону.
Чтобы проиллюстрировать это, попробуйте присвоить 2147483647 (самое большое 
32-разрядное целое со знаком) 32-разрядной переменной типа float (скажем, x), 
а потом напечатайте его. Вы увидите 2147483648. Теперь напечатайте x – 64. Результат – снова 2147483648. Теперь выведите x – 65, и вы получите 2147483520! 
Почему? Потому что промежуток между соседними float составляет в этом диапазоне 128, и операции с такими числами округляются до ближайшего числа 
с плавающей запятой.
В стандарте IEEE числа с плавающей запятой имеют фиксированную точность 
и записываются как числа по основанию 2 в научной нотации: 1.d1
d2…dp 1 ×2e
, где 
p – это точность (24 для типа float, 53 для типа double). Интервал между двумя 
последовательными числами – величина 21–p+e
, которая хорошо аппроксимируется величиной ε|x|, где ε – машинный эпсилон (21–p
).
Зная интервал между соседними числами в окрестности некоторого числа с плавающей запятой, можно избежать классических ошибок в вычислениях. Например, при проведении итеративных вычислений, таких как поиск корня уравнения, нет смысла требовать большей точности, чем способна дать числовая система в окрестности решения. Следите, чтобы затребованная точность не оказалась меньше интервала между числами в окрестности решения, иначе вы 
войдете в бесконечный цикл.
Поскольку числа с плавающей запятой – лишь приближения действительных 
чисел, неизбежно наличие небольшой ошибки. Эта ошибка, называемая ошибкой
округления, бывает причиной неожиданных результатов. Например, при вычитании очень близких чисел наиболее значимые цифры погашают друг друга, 
и тогда в результате положение наиболее значимых занимают те цифры, которые 
были наименее значимыми (и содержали в себе ошибку округления). В сущности, это непоправимо искажает все последующие вычисления. Такое явление называется размыванием (smearing). Нужно внимательно следить за своими алгоритмами, чтобы предотвратить это катастрофическое явление. Для иллюстрации возьмем решение уравнения x2 – 100000x + 1 = 0 по формуле корней квадратного уравнения. Поскольку операнды выражения –b + sqrt(b2 – 4) почти 
равны по величине, можно вместо этого вычислить корень r1 = –b – sqrt(b2 – 4), 
а затем получить r2 = 1/r1
, так как в квадратном уравнении ax2 + bx + c = 0 корни 
удовлетворяют соотношению r1
r2 = c/a.
Размывание может происходить и более скрытым образом. Допустим, что библиотека в коде наивно вычисляет ex по формуле 1 + x + x2
/2 + x3
/3! + …. Этот способ отлично работает для положительных x, но посмотрите, что произойдет, если x будет большим отрицательным числом. Члены с четными степенями окажутся большими положительными числами, а вычитание значений нечетных 
степеней почти не скажется на результате. Проблема в данном случае в том, что 
округление в больших положительных членах происходит в гораздо более значимых позициях, чем у правильного решения. Результат отклоняется к плюс 
бесконечности! Проблема решается просто: для отрицательных x используйте 
формулу ex = 1/e|x|
.
Нечего и говорить, что числа с плавающей запятой нельзя использовать в финансовых приложениях – для них в таких языках, как Python и C#, есть классы 
десятичных чисел. Числа с плавающей запятой предназначены для эффективных научных расчетов. Но эффективность бесполезна, если теряется точность, 
поэтому помните, откуда идут ошибки округления, и пишите соответствующий 
код!