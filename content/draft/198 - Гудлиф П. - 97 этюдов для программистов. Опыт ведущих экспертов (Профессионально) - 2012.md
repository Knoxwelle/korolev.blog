+++
title='198 - Гудлиф П. - 97 этюдов для программистов. Опыт ведущих экспертов (Профессионально) - 2012'
date=2024-07-10T00:00:00-07:00
draft=true
categories=[]
tags=[]
cover_image='/images/cover/knoxwelle__2021-08-08T051054.000Z.jpg'
+++
Ян Кристиаан ван Винкель
Крупный банк с большим количеством филиалов пожаловался, что купленные для кассиров новые компьютеры работают слишком медленно. Это было
еще до повсеместного использования интернет-банкинга, и банкоматы тоже
не были так широко распространены, как сейчас. Люди ходили в банк гораздо
чаще, а из-за медленно работающих компьютеров выстраивались очереди. Через какое-то время банк пригрозил разорвать контракт с поставщиком.
Поставщик направил в банк специалиста по анализу и настройке производительности, чтобы выяснить, в чем причина задержек. Тот быстро нашел
на терминале программу, съедавшую почти всю производительность процессора. Посредством инструмента профилирования он нашел в этой программе функцию, виновную в происходящем. Ее исходный код выглядел так:
for (i=0; i<strlen(s); ++i) {
 if (... s[i] ...) ...
}
При этом строка s обычно содержала несколько тысяч символов. Код (который был написан в самом банке) быстро изменили, и с тех пор банковские
кассиры зажили счастливо...
По­че­му про­грам­ми­сту не при­шло в го­ло­ву ничего умнее, чем написать код 
с квадратичной сложностью без всякой необходимости? 
При каждом вызове strlen программа просматривает каждый из нескольких тысяч символов строки, пока не будет обнаружен завершающий ее нулевой символ. 
Строка при этом не меняется. Заранее вычислив ее длину, программист избавился бы от тысяч вызовов strlen (и миллионов итераций цикла):
n=strlen(s);
for (i=0; i<n; ++i) {
 if (... s[i] ...) ...
}
Правильно выбирайте алгоритмы 
и структуры данныхПравильно выбирайте алгоритмы и структуры данных 199
Всем известен принцип «сделай так, чтобы код работал, потом сделай так, чтобы 
он работал быстро», который направлен против оптимизаций на микроуровне. 
Но по приведенному примеру можно решить, что программист исполнил макиавеллевское адажио «сначала сделай так, чтобы код работал медленно».
Подобная бездумность встречается, и нередко. И дело не только в том, что не нужно «заново изобретать колесо». Иногда молодые программисты бросаются, не особо раздумывая, писать код и вдруг «изобретают» пузырьковую сортировку. При 
этом они, случается, еще и хвастают этим.
Обратной стороной выбора правильного алгоритма является выбор структуры 
данных. Этот выбор может серьезно повлиять на скорость работы: если для хранения коллекции в миллион объектов, по которой нужно выполнять поиск, вы 
используете связный список – а не структуру с хешированием данных либо двоичное дерево, – пользователю найдется что сказать насчет вашего умения программировать.
Программисты должны не изобретать колесо, а по возможности использовать 
имеющиеся библиотеки. Но, чтобы избежать таких проблем, как у вышеупомянутого банка, они должны также обладать знаниями об алгоритмах и возможностях их масштабирования. Что делает современные текстовые редакторы такими же медлительными, как старые программы 0-х типа WordStar – только 
ли навороченный интерфейс? Многие говорят, что в программировании важнейшее значение имеет повторное использование кода. Но прежде всего программист должен знать, когда, что и как использовать повторно. Для этого ему нужно 
знать предметную область, а также алгоритмы и структуры данных.
Хороший программист должен также знать, когда стоит использовать плохой 
алгоритм. Например, если предметная область такова, что в ней не может быть 
больше пяти элементов (скажем, количество костей в покере на костях), вы понимаете, что сортировать придется не более пяти элементов. В таком случае пузырьковая сортировка действительно может оказаться наиболее разумным выбором. На каждой улице бывает праздник.
Поэтому прочтите несколько хороших книг – и хорошенько в них разберитесь. 
А если вы глубоко изучите «Искусство программирования» Дональда Кнута, 
вам может даже повезти: найдите у автора ошибку, и вы получите от него чек на 
один шестнадцатеричный доллар ($2.56).