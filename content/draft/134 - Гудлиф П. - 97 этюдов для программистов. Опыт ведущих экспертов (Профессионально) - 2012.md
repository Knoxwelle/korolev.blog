+++
title='134 - Гудлиф П. - 97 этюдов для программистов. Опыт ведущих экспертов (Профессионально) - 2012'
date=2024-07-10T00:00:00-07:00
draft=true
categories=[]
tags=[]
cover_image='/images/cover/knoxwelle__2021-08-08T051054.000Z.jpg'
+++
Рассел Уиндер
Уже на пер­вых лек­ци­ях по ин­фор­ма­ти­ке про­грам­ми­стов учат, что конкурентные вычисления – и в особенности параллельные как особый подвид конкурентных – вещь трудная, и что лишь лучшим дается надежда справиться с этой задачей, и что даже лучшие не справляются. При этом неизменно уделяется большое внимание потокам, семафорам, мониторам и трудностям организации потоковой безопасности при одновременном доступе к переменным.
Сложных проблем здесь действительно много, и решать их бывает очень трудно. 
Но в чем корень проблем? Общая память. Практически все проблемы конкурентных вычислений, о которых постоянно приходится слышать, касаются общей 
памяти с изменяемыми данными: состояние гонки (race conditions), взаимная 
блокировка (deadlock), активная блокировка (livelock) и т.п. Кажется, ответ очевиден: забудьте о конкурентности либо держитесь подальше от общей памяти!
Отказ от конкурентности почти наверняка не вариант. Количество ядер в ком -
пьютерах возрастает чуть ли не каждый квартал, поэтому достижение настоящего параллелизма становится все важнее. Мы не можем больше полагаться на 
непрерывный рост тактовой частоты процессоров как основу производительности приложений. Производительность может вырасти только за счет параллелизма. Конечно, можно не заботиться о производительности приложений, но едва ли это понравится пользователям.
Так можно ли отказаться от общей памяти? Определенно, да. 
Вместо потоков и общей памяти можно воспользоваться процессами и передачей 
сообщений. Под процессом здесь понимается защищенное независимое состояние 
исполняющегося кода, а не обязательно процесс операционной системы. Такие 
языки, как Erlang (а до него occam), показали, что процессы – весьма удачный 
механизм программирования конкурентных и параллельных систем. В таких 
системах меньше проблем синхронизации, чем в многопоточных системах с общей памятью. Кроме того, существует формальная модель взаимодействующих 
Передача сообщений 
улучшает масштабируемость 
параллельных системПередача сообщений улучшает масштабируемость параллельных систем 135
последовательных процессов (Communicating Sequential Processes, CSP), которую можно применять при разработке таких систем.
Можно пойти дальше и организовать вычисления в виде системы, управляемой
потоком данных (dataflow system). В такой системе нет явно запрограммированного потока управления. Вместо этого создается направленный граф операторов, соединенных путями передачи данных, а затем в систему подаются данные. 
Контроль вычислений осуществляется по готовности данных внутри системы. 
И никаких проблем синхронизации.
При этом для системной разработки применяются главным образом такие языки, как C, C++, Java, Python и Groovy, о которых программистам говорят, что 
они служат для разработки многопоточных систем с общей памятью. Как же 
быть? Решение в том, чтобы использовать – или создавать, если их не существует, – библиотеки и среды, которые предлагают схемы процессов и пересылки сообщений, полностью исключающие применение общей изменяемой памяти.
В итоге отказ от общей памяти в пользу передачи сообщений станет, скорее всего, наиболее удачным методом реализации систем, эффективно использующих 
параллелизм, получивший сегодня повсеместную прописку в компьютерном железе. Занимательно выходит – процессы как единица конкурентного исполнения появились раньше потоков, но в будущем, по-видимому, потоки станут использоваться для реализации процессов.