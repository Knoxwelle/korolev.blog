+++
title='Дэн Норт '
date=2024-07-10T00:00:00-07:00
draft=true
categories=[]
tags=[]
cover_image='/images/cover/knoxwelle__2021-08-08T051054.000Z.jpg'
+++
Дэн Норт 
Пред­ставь­те се­бе текст двух про­грамм. В одной вы встречаете такое:
if (portfolioIdsByTraderId.get(trader.getId())
 containsKey(portfolio.getId())) {...}
Вы чешете затылок, пытаясь осмыслить, что делает этот код. Похоже, он получает идентификатор объекта трейдера, и по этому идентификатору находится 
ассоциативный массив в, э-э-э… очевидно, ассоциативном массиве ассоциативных массивов; затем проверяется, есть ли в этом внутреннем массиве еще один 
идентификатор – из объекта портфеля. Вы снова чешете затылок. Ищете объявление переменной portfolioIdsByTraderId и обнаруживаете следующее:
Map<int, Map<int, int>> portfolioIdsByTraderId;
Понемногу вы начинаете понимать, что это как-то связано с наличием у трейдера доступа к определенному портфелю. Конечно, вы найдете такой же фрагмент 
поиска – а скорее похожий, но немного отличающийся код, – когда в другом месте понадобится узнать, есть ли у трейдера доступ к некоторому портфелю.
В тексте другой программы вы видите:
if (trader.canView(portfolio)) {...}
Никаких головоломок. Вам не нужно знать, как объект трейдера определяет 
доступность портфеля. Где-то в недрах программы, наверное, все же зарыт ассоциативный массив ассоциативных массивов. Но это заботы объекта trader, а не 
ваши.
Внимание, вопрос. Над кодом какой из программ вы предпочли бы работать?
Давным-давно у нас были только самые элементарные структуры данных: биты, 
байты и символы (на самом деле, те же байты, но мы делали вид, что это буквы 
и специальные символы). С десятичными числами выходило посложнее, ведь 
счисление по основанию 10 плохо вписывается в двоичную систему, так что у нас 
было несколько размеров для чисел с плавающей запятой. Затем появились 
Пишите код 
на языке предметной областиПишите код на языке предметной области 43
массивы и строки (по сути, разновидность массивов). Потом в нашем распоряжении оказались стеки и очереди, хеши, связные списки, списки с пропусками 
и масса других замечательных структур данных, которых нет в реальном мире. 
Термин «компьютерная наука» тогда означал в основном трудоемкое отображение реального мира на наши ограниченные структуры данных. Настоящие гуру 
могут даже вспомнить, как именно удавалось решать задачу.
Затем появились пользовательские типы! Ладно, это ни для кого не новость, но 
они несколько меняют правила игры. Если в вашей предметной области есть такие понятия, как «трейдер» и «портфель», вы можете моделировать их с помощью типов, назначив типам такие имена, как Trader и Portfolio. Но, что еще важнее, и отношения между типами можно моделировать через термины из той же 
предметной области.
Если вы не используете в коде термины предметной области, значит вы формируете подразумеваемое (читай: секретное) правило, что вот эта переменная типа int в этом месте обозначает трейдера, а вон то int в том месте обозначает портфель. (И лучше их не путать!) А если вы реализуете некоторое бизнес-правило 
(«некоторым трейдерам нельзя просматривать некоторые портфели – это незаконно») с помощью нетривиального алгоритма в коде, – например поиска существования значения в ассоциативном массиве, – вы вряд ли облегчаете жизнь 
ребятам, которые будут проводить аудит и проверку на соответствие законодательству.
Следующему программисту, который будет работать с этим кодом, ваше тайное 
знание может быть недоступно, так почему не описать все явно? Применение одного ключа для поиска другого, используемого в проверке существования, не 
слишком очевидная штука. Можно ли рассчитывать, что кто-нибудь догадается, что таким образом реализуются бизнес-правила, препятствующие конфликту интересов?
Явное применение понятий предметной области в коде дает возможность другим 
программистам понять его назначение со значительно меньшими усилиями, чем 
при попытках сопоставить алгоритм с тем, что им известно о предметной области. Кроме того, при совершенствовании модели предметной области, которое 
происходит по мере расширения ваших знаний о ней, вам будет легче дорабатывать код. Если правильно организовать инкапсуляцию, велики шансы, что правило будет располагаться в одном-единственном месте, и вы сможете менять его 
так, что никакой вызывающий код этого не заметит.
Программист, который спустя несколько месяцев продолжит работу над вашим 
кодом, будет вам благодарен. И этим программистом можете оказаться вы сами.