+++
title='202 - Гудлиф П. - 97 этюдов для программистов. Опыт ведущих экспертов (Профессионально) - 2012'
date=2024-07-10T00:00:00-07:00
draft=true
categories=[]
tags=[]
cover_image='/images/cover/knoxwelle__2021-08-08T051054.000Z.jpg'
+++
Кирк Пеппердин
Зна­чи­мость прин­ци­па DRY (Don’t Repeat Yourself – не повторяйся) состоит в том, 
что он формализует следующую идею: каждый элемент знаний в системе должен 
иметь единственное представление. Иными словами, знание должно ограничиваться единственной реализацией. Полную противоположность DRY представляет WET (Write Every Time – пиши каждый раз). Наш код можно назвать «сырым» (WET), когда знание представлено в коде одновременно несколькими способами. Скрытое влияние DRY и WET на производительность становится понятным после рассмотрения их многочисленных эффектов на конкретном примере.
Рассмотрим некоторую функциональность нашей системы (назовем ее X), являющуюся узким местом для процессора. Допустим, что функция X потребляет 
30% мощности процессора. Теперь предположим, что у функции X есть 10 различных реализаций. В среднем каждая реализация потребляет 3% процессорного времени. Поскольку такой уровень использования процессора не вызывает 
беспокойства, при беглом анализе можно не заметить, что эта функция создает 
узкое место. Но допустим, что мы каким-то образом выяснили, что функция X – 
узкое место. Тогда ставится задача найти и исправить каждую реализацию. Для 
WET у нас есть 10 разных реализаций, которые нужно найти и исправить. В случае DRY мы сразу увидим загрузку процессора в 30%, а размер кода для исправления будет в 10 раз меньше. К тому же не потребуется выискивать все многочисленные реализации.
Есть один сценарий, в котором мы часто нарушаем DRY, а именно при работе 
с коллекциями. Стандартный прием реализации запроса заключается в проходе 
по коллекции и применении запроса к каждому ее элементу:
public class UsageExample {
 private ArrayList<Customer> allCustomers = new ArrayList<Customer>();
 // ...
 public ArrayList<Customer> findCustomersThatSpendAtLeast(Money amount) {
 ArrayList<Customer> customersOfInterest = new ArrayList<Customer>();
 for (Customer customer: allCustomers) {
WET размазывает узкие 
места производительности WET размазывает узкие места производительности 203
 if (customer.spendsAtLeast(amount))
 customersOfInterest.add(customer);
 }
 return customersOfInterest;
 }
}
Сделав эту коллекцию напрямую доступной клиентам, мы нарушили принцип 
инкапсуляции. Это не только снижает потенциал рефакторинга, но и заставляет 
пользователей кода нарушать DRY, поскольку каждому из них придется заново 
реализовывать потенциально идентичный запрос. Такой ситуации легко избежать, если убрать открытые коллекции из API. В данном примере можно ввести 
новый предметно-ориентированный тип коллекции с именем CustomerList. Этот 
класс семантически лучше согласован с предметной областью. Естественным образом он станет местом, в котором содержатся все наши запросы.
Наличие этого нового типа-коллекции позволит также легко выяснить, являются ли эти запросы узким местом в смысле производительности. Включив запросы в класс, мы устраняем необходимость открывать клиентам варианты представления, такие как ArrayList. Это дает нам свободу для последующего изменения реализаций без нарушения контрактов с клиентами:
public class CustomerList {
 private ArrayList<Customer> customers = new ArrayList<Customer>();
 private SortedList<Customer> customersSortedBySpendingLevel =
 new SortedList<Customer>();
 // ...
 public CustomerList findCustomersThatSpendAtLeast(Money amount) {
 return new CustomerList(
 customersSortedBySpendingLevel.elementsLargerThan(amount));
 }
}
public class UsageExample {
 public static void main(String[] args) {
 CustomerList customers = new CustomerList();
 // ...
 CustomerList customersOfInterest =
 customers.findCustomersThatSpendAtLeast(someMinimalAmount);
 // ...
 }
}
В этом примере следование принципу DRY позволило нам ввести измененную 
систему индексирования, в которой используется SortedList, а ключом служит 
объем трат наших покупателей. И, если абстрагироваться от данного примера, 
намного важнее, что следование DRY помогло найти и исправить узкое место. 
Пиши мы код по принципу WET, сделать это было бы труднее.