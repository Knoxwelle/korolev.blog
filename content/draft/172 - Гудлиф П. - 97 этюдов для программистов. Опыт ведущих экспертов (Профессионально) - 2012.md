+++
title='172 - Гудлиф П. - 97 этюдов для программистов. Опыт ведущих экспертов (Профессионально) - 2012'
date=2024-07-10T00:00:00-07:00
draft=true
categories=[]
tags=[]
cover_image='/images/cover/knoxwelle__2021-08-08T051054.000Z.jpg'
+++
Роберт Мартин (Дядюшка Боб)
Вот один из наи­бо­лее фун­да­мен­таль­ных прин­ци­пов ка­че­ст­вен­но­го про­ек­ти­рова­ния:
Собрать вместе те вещи, которые изменяются по одной и той же причине, и разделить те, которые изменяются по разным причинам.
Этот принцип иначе известен как принцип единственной ответственности, 
или SRP (single responsibility principle). Если коротко, он гласит, что причина 
изменения любой подсистемы, класса и даже функции должна быть ровно одна. 
Классический пример – класс с методами для работы с бизнес-правилами, отчетами и базами данных:
public class Employee {
public Money calculatePay() ...
public String reportHours() ...
public void save() ...
}
Кое-кто из программистов считает, что сочетание этих трех функций в одном 
классе вполне уместно. В конце концов, классы и должны собирать вместе функции, работающие с одними и теми же переменными. Однако проблема в том, что 
все три функции изменяются по совершенно разным причинам. Функция calculatePay (рассчитать зарплату) изменяется вместе с бизнес-правилами расчета заплаты. Функция reportHours (отчитаться о часах) изменяется, когда требуется 
другой формат отчета. Функция save (сохранить) изменяется, когда администратор базы данных меняет схему базы данных. В совокупности эти три причины 
делают Employee очень неустойчивым классом. Он будет меняться по каждой из 
этих причин. И что еще важнее, эти изменения затронут любые классы, которые 
зависят от Employee.
В хорошей архитектуре система разделена на компоненты, которые можно развернуть независимо. Независимость развертывания означает, что изменение одного компонента не требует повторного развертывания других. Но если Employee
Принцип единственной 
ответственностиПринцип единственной ответственности 173
интенсивно используется многими классами в других компонентах, каждое изменение Employee может требовать повторного развертывания других компонентов, что сводит на нет основное преимущество компонентного подхода к проектированию (или SOA, если вам нравится это более модное название). Следующее 
простое разделение решает проблему:
public class Employee {
 public Money calculatePay() ...
}
public class EmployeeReporter {
 public String reportHours(Employee e) ...
}
public class EmployeeRepository {
 public void save(Employee e) ...
}
Каждый класс можно поместить в отдельный компонент. Или, выражаясь точнее, все классы, создающие отчеты, поместить в компонент отчетов. Все классы, 
связанные с базами данных, можно поместить в компонент хранилища. А все 
бизнес-правила поместить в компонент бизнес-правил.
Внимательный читатель заметит, что в приведенном решении остаются зависимости. Другие классы по-прежнему зависят от Employee. Поэтому если Employee
изменится, вполне возможно, что эти классы придется заново скомпилировать 
и развернуть. Таким образом, Employee невозможно модифицировать, а потом 
развернуть независимо. Однако другие классы можно модифицировать и независимо развернуть. Никакая их модификация не требует перекомпиляции и повторного развертывания остальных классов. Даже Employee можно независимо 
развернуть, если тщательно применить принцип инверсии зависимости (DIP, 
dependency inversion principle), но это уже тема для другой книги.1
Продуманное применение принципа единственной ответственности, то есть разделение тех сущностей, которые изменяются по разным причинам, является одной из основ создания архитектур со структурой независимо развертываемых 
компонентов.
1 http://www.amazon.com/dp/0135974445/