+++
title='Йехиль Кимхи '
date=2024-07-10T00:00:00-07:00
draft=true
categories=[]
tags=[]
cover_image='/images/cover/knoxwelle__2021-08-08T051054.000Z.jpg'
+++
Йехиль Кимхи 
По­пыт­ки до­ка­зать кор­рект­ность про­грамм­но­го обес­пе­че­ния вруч­ную приводят к формальному доказательству, которое длиннее самого кода и содержит 
ошибки с большей вероятностью, чем сам код. Желательно применять автоматизированные средства, но это не всегда возможно. Ниже описывается срединный путь: полуформальное доказательство корректности.
Метод основан на разделении исследуемого кода на короткие фрагменты размером от одной строки, которая может содержать вызов функции, до блоков длиной не более 10 строк и обсуждении их корректности. Доказательство должно 
оказаться достаточно убедительным для вашего коллеги, играющего роль «адвоката дьявола».
Фрагменты следует выбирать таким образом, чтобы в конечной точке блока 
состояние программы (а именно счетчик адреса команд и значения всех «живых» 
объектов) удовлетворяло простому в описании свойству, а функциональность 
этого фрагмента (преобразование состояния) легко описывалась в виде одной независимой задачи. Соблюдение предложенных правил упрощает ведение доказательства. Такие свойства конечной точки фрагмента обобщают понятия предусловий и постусловий для функций, а также инвариантов для циклов и классов (в отношении экземпляров классов). Необходимо стремиться, чтобы фрагменты как можно меньше зависели друг от друга, что облегчает доказательство 
и очень пригодится, если предполагается изменять эти фрагменты.
Многие хорошо известные (хотя и, видимо, реже применяемые) и имеющие статус «качественных» практики написания кода также облегчают проведение доказательств. Таким образом, одно лишь намерение провести в будущем доказательство корректности своего кода способствует улучшению его стиля и структуры. Не стоит удивляться, что большинство подобных практик проверяется 
статическими анализаторами кода:
• Избегайте операторов goto, потому что они создают сильную зависимость между фрагментами, разнесенными в коде.
Пиши код с умомПиши код с умом 51
• Избегайте изменяемых глобальных переменных, потому что они делают зависимыми между собой все фрагменты, в которых используются.
• Область видимости каждой переменной должна быть наименьшей из возможных. Например, локальный объект можно объявить непосредственно перед 
первым использованием.
• Делайте объекты неизменяемыми (immutable), где это возможно.
• Улучшайте читаемость кода посредством пробелов – как горизонтальных, так 
и вертикальных. Например, выравнивайте отступы для родственных структур и разделяйте фрагменты кода пустыми строками.
• Пишите самодокументируемый код, выбирая содержательные (но достаточно 
короткие) имена для объектов, функций, типов и т.д.
• Если фрагмент оказывается вложенным, превратите его в функцию.
• Каждая функция должна решать единственную задачу и быть короткой. Ограничение длины функции 24 строками, введенное много лет назад, по-прежнему действует. Размер и разрешение экрана по сравнению с 60-ми годами прошлого века увеличились, но человеческие возможности восприятия остались 
прежними.
• У функции не должно быть много аргументов (хорошая практика – не более 
четырех). Это не ограничивает объем передаваемых функции данных: объединение родственных аргументов в одном объекте локализует инварианты объекта, что упрощает доказательство в плане проверки согласованности и состояний объектов.
• В общем случае каждая единица кода, начиная с фрагмента и заканчивая целой библиотекой, должна иметь ограниченный интерфейс. Сокращение потока информации упрощает доказательство. Это означает, что следует избегать 
методов, возвращающих внутреннее состояние (getters). Нужно не запрашивать у объекта информацию для обработки, а требовать, чтобы он выполнил 
работу с той информацией, которая у него уже есть. Иными словами, инкапсуляция – это ограниченные интерфейсы, и только они.
• Чтобы сохранить инварианты класса, следует избегать методов, присваивающих значения (setters). Они часто влекут нарушение инвариантов, определяющих состояния объекта.
Доказательство корректности кода, как и его обсуждение, позволит вам лучше 
в нем разобраться. Сообщайте о своих открытиях – это пойдет всем на пользу.