+++
title='188 - Гудлиф П. - 97 этюдов для программистов. Опыт ведущих экспертов (Профессионально) - 2012'
date=2024-07-10T00:00:00-07:00
draft=true
categories=[]
tags=[]
cover_image='/images/cover/knoxwelle__2021-08-08T051054.000Z.jpg'
+++
Никлас Нильссон
У тех, кто жи­вет в ре­аль­ном ми­ре, странные представления о том, что такое состояние. Сегодня утром я заехал в местный магазин, чтобы подготовиться к очередному дню переработки кофеина в код. Я предпочитаю это делать за чашечкой 
латте, а поскольку я не нашел в продаже молока, то обратился к сотруднице магазина. 
«У нас абсолютно, ну совершенно абсолютно закончились запасы молока». 
Программисту странно слышать такое высказывание. Либо у вас закончилось 
молоко, либо нет. Не существует каких-то промежуточных степеней отсутствия 
молока. Возможно, мне пытались сообщить, что молока не будет целую неделю, 
но результат тот же: придется весь день пить эспрессо.
В большинстве практических ситуаций такое легкомысленное отношение людей к состояниям не вызывает никаких проблем. К несчастью, многие программисты тоже имеют весьма смутное представление о состояниях, а это уже проблема.
Рассмотрим простой интернет-магазин, который принимает к оплате только кредитные карты и не выписывает клиентам счета. При этом класс Order (заказ) содержит такой метод:
public boolean isComplete() {
 return isPaid() && hasShipped();
}
Разумно, так? Так вот, хоть это выражение и выделено в аккуратный метод, а не 
разбросано по всему коду путем копирования и вставки, его вообще не должно 
существовать. А то, что оно существует, указывает на проблему. Какую? Нельзя 
доставить заказ, прежде чем он оплачен. Поэтому hasShipped не может вернуть 
true, пока isPaid не вернет true, а в этом случае часть выражения избыточна. 
Возможно, вам все же нужен метод isComplete для ясности кода, но тогда он должен выглядеть как-то так:
Думайте состояниямиДумайте состояниями 189
public boolean isComplete() {
 return hasShipped();
}
В своей работе я постоянно сталкиваюсь и с недостающими, и с избыточными 
проверками. Я привел крошечный пример, но если добавить сюда отмену заказа 
и возврат денег, дело усложняется, и потребность в правильной обработке состояний возрастает. В данном случае заказ может находиться только в одном из 
трех разных состояний:
• В про­цес­се: можно добавлять и удалять товары. Нельзя осуществлять доставку.
• Оп­ла­чен: нельзя добавлять и удалять товары. Можно доставлять.
• Дос­тав­лен: конец. Больше никаких изменений.
Наличие этих состояний важно, и перед выполнением операций следует проверять, что вы в нужном состоянии, а также проверять, что из текущего состояния 
вы перейдете в допустимое. Короче, нужно защищать объекты тщательно и в правильных местах.
Но как начать думать состояниями? Выделить выражения в осмысленные методы – очень хорошее начало, но это лишь начало. Главное – понимать конечные 
автоматы. Знаю, у вас сохранились неприятные воспоминания о них из курса 
информатики, но оставьте это в прошлом. Конечные автоматы – это не особенно 
сложно. Рисуйте их, тогда их легче понять и обсуждать. Запускайте свой код 
в тестовом режиме, чтобы разделить допустимые и недопустимые состояния, 
а также переходы между ними, и поддерживать их корректность. Изучите шаблон State. Освоившись с ним, почитайте о контрактном программировании (design by contract). Оно помогает обеспечить допустимость состояния путем проверки данных и самого объекта на входе и выходе из каждого открытого метода.
Если состояние некорректно, значит, в коде ошибка, и вы рискуете потерять данные, если не прервете выполнение. Если вам кажется, что проверки состояний 
замусоривают код, научитесь скрывать их с помощью специальных инструментов, генерации кода, вплетений (weaving) или аспектов. Независимо от того, какой метод вы выберете, подход на основе состояний сделает ваш код более простым и надежным.