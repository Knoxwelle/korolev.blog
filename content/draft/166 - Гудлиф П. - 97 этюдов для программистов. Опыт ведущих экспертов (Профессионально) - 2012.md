+++
title='166 - Гудлиф П. - 97 этюдов для программистов. Опыт ведущих экспертов (Профессионально) - 2012'
date=2024-07-10T00:00:00-07:00
draft=true
categories=[]
tags=[]
cover_image='/images/cover/knoxwelle__2021-08-08T051054.000Z.jpg'
+++
Сэм Сааристе
Шаб­лон Singleton ре­ша­ет мно­гие ва­ши про­бле­мы. Вы знаете, что вам нужен 
единственный экземпляр. Вы получаете гарантию, что этот экземпляр будет 
инициализирован перед использованием. Архитектура остается простой благодаря наличию глобальной точки доступа. Все прекрасно. Ну что может не понравиться в этом классическом шаблоне проектирования?
Если подумать, то весьма многое. Как ни соблазнительно применение синглтонов, 
они, как показывает опыт, приносят больше вреда, чем пользы. Они затрудняют 
тестирование и усложняют сопровождение. К сожалению, это понимание не 
столь распространено, как хотелось бы, и синглтоны сохраняют свое обаяние для 
множества программистов. Хотя есть основания задуматься, так ли они хороши:
• Ограничение на число экземпляров класса часто иллюзорно. Во многих случаях утверждение, что в будущем не понадобятся дополнительные экземпляры, ничем не подкреплено. Домыслы в основе архитектуры приложения обязательно приведут к неприятностям в будущем. Технические требования меняются. Хорошая архитектура это учитывает. Синглтоны – нет.
• Синглтоны создают неявные зависимости между концептуально независимыми модулями кода. Беда в том, что, во-первых, эти зависимости незаметны, а во-вторых, создают ненужные связи между модулями. Этот запашок 
в коде становится острее, когда вы пытаетесь писать модульные тесты, основанные на слабом связывании и возможности выборочно применять реализации-макеты вместо настоящих. Синглтоны не дают осуществлять такое простое моделирование.
• Синглтоны неявно хранят состояние, что опять-таки препятствует модульному тестированию. Модульное тестирование предполагает, что тесты 
независимы друг от друга, благодаря чему их можно выполнять в любом порядке, а программу можно возвращать в известное состояние перед выполнением каждого модульного теста. Как только появляются синглтоны с изменяемым (mutable) состоянием, обеспечить такие условия может оказаться 
Не поддавайтесь очарованию 
шаблона SingletonНе поддавайтесь очарованию шаблона Singleton 167
затруднительно. Кроме того, такое глобально доступное долгоживущее состояние затрудняет интерпретацию кода человеком, особенно в многопоточной среде.
• Многопоточность создает дополнительные капканы в использовании шаблона синглтона. Поскольку простая блокировка доступа не очень эффективна, получила распространение так называемая блокировка с двойной проверкой (DCLP). К несчастью, иногда это просто другая разновидность рокового 
влечения. Оказалось, что во многих языках DCLP не является потоково-безопасной, и даже в тех, где она является потоково-безопасной, сохраняются 
возможности для ее неправильной работы. 
Избавление от синглтонов может стать в окончательном итоге сложной задачей:
• Явное уничтожение объектов синглтонов не поддерживается. В отдельных 
контекстах это может оказаться проблемой, например в архитектуре с подключаемыми модулями, где модуль можно безопасно выгрузить, только если 
все его объекты удалены из памяти.
• При завершении программы порядок неявной зачистки синглтонов не определен. Это может вызвать проблемы в приложениях, содержащих синглтоны 
с взаимными зависимостями. При завершении таких приложений одни синглтоны могут продолжать обращаться к другим, которые к тому моменту уже 
уничтожены.
Некоторые из перечисленных недостатков можно преодолеть с помощью специальных механизмов. Однако за это приходится расплачиваться усложнением 
кода, чего удалось бы избежать, если бы в проекте использовались иные подходы к архитектуре.
Поэтому ограничьте использование шаблона Singleton теми классами, для которых действительно не должно никогда создаваться более одного экземпляра. Не 
стоит пользоваться глобальной точкой входа в синглтон в произвольных участках кода. Прямое обращение к синглтону должно происходить лишь в нескольких четко определенных местах и быть доступным коду в целом только через 
узкий интерфейс. Весь остальной код не знает, как реализован интерфейс – через синглтон или какой-то другой класс, – а потому не зависит от реализации. 
В результате всего этого разрушаются связи, мешающие модульному тестированию, и облегчается сопровождение. Так что надеюсь, что, когда вы в следующий 
раз решите реализовать синглтон или к нему обратиться, вы дважды подумаете, 
стоит ли это делать.