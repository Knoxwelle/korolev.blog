<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Application on Tiny Dev Blog</title>
    <link>http://localhost:1313/tags/application/</link>
    <description>Recent content in Application on Tiny Dev Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 06 Aug 2024 00:00:00 -0700</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/application/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Application performance determined by architecture</title>
      <link>http://localhost:1313/posts/application-performance-determined-by-architecture/</link>
      <pubDate>Tue, 06 Aug 2024 00:00:00 -0700</pubDate>
      <guid>http://localhost:1313/posts/application-performance-determined-by-architecture/</guid>
      <description>An application&amp;rsquo;s performance is determined by its architecture. On the surface, this claim seems obvious, but actual experience suggests otherwise. For example, software architects frequently believe that switching to a different software infrastructure manufacturer can alleviate application performance difficulties. This idea may have originated from the hype around test findings; for example, assertions that the product of the top company outperforms that of its nearest competitor by 25% may have contributed to the development of this view. However, if the leading product completes the operation in 3 milliseconds and the competitor product completes it in 4 milliseconds, the reported 25% (one millisection) represents virtually little given the overall low performance, which is caused by architectural inefficiencies.&#xA;In addition to IT managers and performance testing teams, other groups of people advise you to carry out the subtle configuration of the application&amp;rsquo;s infrastructure, like experimenting with memory allocation operations, connectivity pool sizes, flow pool sizes, and so forth.</description>
    </item>
    <item>
      <title>Using a database as a fort</title>
      <link>http://localhost:1313/posts/using-a-database-as-a-fort/</link>
      <pubDate>Tue, 21 May 2024 00:00:00 -0700</pubDate>
      <guid>http://localhost:1313/posts/using-a-database-as-a-fort/</guid>
      <description>The database contains all of the information, both that entered by employees and that obtained from clients. Changes in user interfaces, business logic, applied logic, and even staff don&amp;rsquo;t affect the data. It is imperative that a reliable data model be created as early in the project as possible.&#xA;Prewriting complex, comprehensive technical requirements is a thing of the past! The new school demands that products be delivered frequently and early.Writing one line of vulnerable code is better than writing 10 in your head. When it comes to the facts, at least, it looks too good to be true.&#xA;Data structures and their relationships usually do not change quickly, although user interfaces and business logic do. Because of this, it&amp;rsquo;s imperative to define the data model precisely from the start, both analytically and structurally.</description>
    </item>
  </channel>
</rss>
