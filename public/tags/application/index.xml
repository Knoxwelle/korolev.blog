<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Application on Tiny Dev Blog</title>
    <link>http://localhost:1313/tags/application/</link>
    <description>Recent content in Application on Tiny Dev Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 10 Aug 2024 00:00:00 -0700</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/application/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Application performance determined by architecture</title>
      <link>http://localhost:1313/posts/application-performance-determined-by-architecture/</link>
      <pubDate>Sat, 10 Aug 2024 00:00:00 -0700</pubDate>
      <guid>http://localhost:1313/posts/application-performance-determined-by-architecture/</guid>
      <description>The architecture of an application determines its performance. Although this claim appears clear at first glance, practical experience indicates otherwise. Software architects, for instance, frequently think that application performance issues can be resolved by simply moving to a different software infrastructure manufacturer. This notion could have its roots in the noise surrounding test results; for instance, claims that the leading company&amp;rsquo;s product performs 25% better than its closest rival&amp;rsquo;s could be the cause of this belief. However, given the overall low performance, which stems from architectural inefficiencies, the stated 25% (one millisection) means relatively little if the competition product completes the operation in 4 milliseconds and the leading product completes it in 3 milliseconds.&#xA;Other groups of people, like the developers&amp;rsquo; support service and the authors of the books on app performance management, advise you to perform the subtle configuration of the application&amp;rsquo;s infrastructure, such as experimenting with memory allocation operations, connectivity pool sizes, flow pool sizes, and so forth, in addition to IT managers and performance testing teams.</description>
    </item>
    <item>
      <title>Database as Fortress</title>
      <link>http://localhost:1313/posts/database-as-fortress/</link>
      <pubDate>Fri, 17 May 2024 00:00:00 -0700</pubDate>
      <guid>http://localhost:1313/posts/database-as-fortress/</guid>
      <description>All information, both entered by staff members and received from clients, is kept in the database datax. Data remains constant despite changes in user interfaces, business logic, applied logic, and even personnel.The significance of developing a trustworthy data model early on in the project cannot be overstated.&#xA;The days of prewriting intricate, detailed technical specifications are long gone! Early and frequent product delivery is required by the new school.It is preferable to write one line of vulnerable code than ten lines in your mind.It seems too good to be true, at least when it comes to the facts.&#xA;Although user interfaces and business logic change quickly, data structures and their connections typically do not. As a result, it&amp;rsquo;s critical to establish a precise definition of the data model early on, both structurally and analytically.</description>
    </item>
  </channel>
</rss>
