<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Use on Korolev Blog</title>
    <link>http://localhost:1313/tags/use/</link>
    <description>Recent content in Use on Korolev Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 14 Feb 2025 00:00:00 -0700</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/use/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Interfaces</title>
      <link>http://localhost:1313/posts/interfaces/</link>
      <pubDate>Fri, 14 Feb 2025 00:00:00 -0700</pubDate>
      <guid>http://localhost:1313/posts/interfaces/</guid>
      <description>One of the most common tasks in software development is interface specification. Interfaces exist at the highest level of abstraction (user interfaces), at the lowest level (function interfaces), and at intermediate levels (class interfaces, libraries, etc.). Regardless of what you are doing—aligning with end users on their future interaction with the system, collaborating with developers to develop the API specification, or declaring private class functions—interface design is an important part of your job. If you handle it well, using your interfaces will be a pure pleasure, and user productivity will increase. If you handle the task poorly, your interfaces will become a source of frustration and errors.&#xA;Good interfaces possess the following properties:&#xA;They are easy to use correctly. Users of a well-designed interface almost always use it correctly because that is the path of least resistance for that interface.</description>
    </item>
    <item>
      <title>Know how to use command line utilities</title>
      <link>http://localhost:1313/posts/know-how-to-use-command-line-utilities/</link>
      <pubDate>Mon, 19 Aug 2024 00:00:00 -0700</pubDate>
      <guid>http://localhost:1313/posts/know-how-to-use-command-line-utilities/</guid>
      <description>Today, many software development tools are delivered as integrated development environments (IDEs). Besides the two popular examples – Visual Studio from Microsoft and Eclipse from the open-source community – there are many others. A lot can be said in favor of IDEs. They are easy to use and they free the programmer from the need to delve into many minor details, including the build process.&#xA;However, ease of use has its downside. A tool is usually easy to use when it makes decisions for the programmer and automatically does a large amount of work behind the scenes. Therefore, if you only use an IDE as your programming environment, it is quite possible that you will never fully understand what your tools are actually doing.</description>
    </item>
  </channel>
</rss>
