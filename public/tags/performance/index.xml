<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Performance on Tiny Dev Blog</title>
    <link>http://localhost:1313/tags/performance/</link>
    <description>Recent content in Performance on Tiny Dev Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 10 Aug 2024 00:00:00 -0700</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/performance/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Application performance determined by architecture</title>
      <link>http://localhost:1313/posts/application-performance-determined-by-architecture/</link>
      <pubDate>Sat, 10 Aug 2024 00:00:00 -0700</pubDate>
      <guid>http://localhost:1313/posts/application-performance-determined-by-architecture/</guid>
      <description>The performance of an application is determined by its architecture. At first glance, this assertion seems obvious, but real-life experience shows the opposite. For example, software architects often believe that application performance problems can be solved by simply switching to the software infrastructure from another manufacturer. The source of this belief may be a river of noise around the test results; for example, it is stated that the product of the leading company is 25% superior in performance to the nearest competitor. However, if the leader product performs the operation in 3 milliseconds and the competitor product in 4 milliseconds, the stated 25% (one millisection) means very little against the background of the overall low performance, which is rooted in architecture inefficiency. In addition to IT managers and performance testing teams, there are other groups of people, such as the developer&amp;rsquo;s support service and the authors of the app performance management books, who recommend that you do the subtle configuration of the application&amp;rsquo;s infrastructure: play with memory allocation operations, connectivity pool sizes, flow pool size, and so on.</description>
    </item>
    <item>
      <title>Думать о производительности никогда не рано</title>
      <link>http://localhost:1313/posts/%D0%B4%D1%83%D0%BC%D0%B0%D1%82%D1%8C-%D0%BE-%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%B4%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D0%BD%D0%B8%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0-%D0%BD%D0%B5-%D1%80%D0%B0%D0%BD%D0%BE/</link>
      <pubDate>Sun, 30 Jun 2024 00:00:00 -0700</pubDate>
      <guid>http://localhost:1313/posts/%D0%B4%D1%83%D0%BC%D0%B0%D1%82%D1%8C-%D0%BE-%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%B4%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D0%BD%D0%B8%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0-%D0%BD%D0%B5-%D1%80%D0%B0%D0%BD%D0%BE/</guid>
      <description>The needs of users of business applications manifest primarily in functional requirements. Non-functional aspects of the system (such as performance, flexibility, downtime, support needs, etc.) are in the architect’s hands. At the same time, preliminary testing of non-functional requirements is often postponed to a very late stage of the development cycle and sometimes fully delegated to the system maintenance team.&#xA;This mistake is much more common than it should be. It can be based on various reasons.Worrying about the speed and flexibility of the program, which is not yet exactly performing the required function, may seem pointless. Test environments and tests themselves are quite complex.Early working versions of the system may not be exposed to a realistic load due to insufficient intensity of use.</description>
    </item>
  </channel>
</rss>
