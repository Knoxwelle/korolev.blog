<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Performance on Tiny Dev Blog</title>
    <link>http://localhost:1313/tags/performance/</link>
    <description>Recent content in Performance on Tiny Dev Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 10 Aug 2024 00:00:00 -0700</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/performance/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Application performance determined by architecture</title>
      <link>http://localhost:1313/posts/application-performance-determined-by-architecture/</link>
      <pubDate>Sat, 10 Aug 2024 00:00:00 -0700</pubDate>
      <guid>http://localhost:1313/posts/application-performance-determined-by-architecture/</guid>
      <description>The architecture of an application determines its performance. Although this claim appears clear at first glance, practical experience indicates otherwise. Software architects, for instance, frequently think that application performance issues can be resolved by simply moving to a different software infrastructure manufacturer. This notion could have its roots in the noise surrounding test results; for instance, claims that the leading company&amp;rsquo;s product performs 25% better than its closest rival&amp;rsquo;s could be the cause of this belief. However, given the overall low performance, which stems from architectural inefficiencies, the stated 25% (one millisection) means relatively little if the competition product completes the operation in 4 milliseconds and the leading product completes it in 3 milliseconds.&#xA;Other groups of people, like the developers&amp;rsquo; support service and the authors of the books on app performance management, advise you to perform the subtle configuration of the application&amp;rsquo;s infrastructure, such as experimenting with memory allocation operations, connectivity pool sizes, flow pool sizes, and so forth, in addition to IT managers and performance testing teams.</description>
    </item>
    <item>
      <title>It is never too early to think about productivity</title>
      <link>http://localhost:1313/posts/it-is-never-too-early-to-think-about-productivity/</link>
      <pubDate>Sun, 30 Jun 2024 00:00:00 -0700</pubDate>
      <guid>http://localhost:1313/posts/it-is-never-too-early-to-think-about-productivity/</guid>
      <description>Functional requirements are where business application users&amp;rsquo; needs are mostly expressed. The architect is in charge of the system&amp;rsquo;s non-functional elements, which include performance, flexibility, downtime, support requirements, etc. Simultaneously, initial testing of non-functional needs is sometimes completely assigned to the system maintenance team or delayed until a very late point in the development cycle.&#xA;This is a far more frequent error than it ought to be. It may be founded on a number of factors.It may seem futile to worry about the program&amp;rsquo;s speed and adaptability when it isn&amp;rsquo;t precisely fulfilling the necessary role yet. Both the test settings and the tests themselves are highly intricate. Due to low use intensity, early working versions of the system might not have been subjected to a realistic load.</description>
    </item>
  </channel>
</rss>
