<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data on Korolev Blog</title>
    <link>http://localhost:1313/tags/data/</link>
    <description>Recent content in Data on Korolev Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 22 Sep 2024 00:00:00 -0700</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/data/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Message passing improves the scalability of parallel systems</title>
      <link>http://localhost:1313/posts/message-passing-improves-the-scalability-of-parallel-systems/</link>
      <pubDate>Sun, 22 Sep 2024 00:00:00 -0700</pubDate>
      <guid>http://localhost:1313/posts/message-passing-improves-the-scalability-of-parallel-systems/</guid>
      <description>Already in the first lectures on computer science, programmers are taught that concurrent computing – and especially parallel computing as a special subtype of concurrent computing – is a difficult task, and that only the best have a hope of coping with it, and that even the best do not manage to do so. Great attention is invariably paid to threads, semaphores, monitors, and the difficulties of organizing thread safety with simultaneous access to variables.&#xA;There are indeed many complex problems here, and solving them can be very difficult. But what is the root of the problems? Shared memory. Almost all the problems of concurrent computing that we constantly hear about are related to shared memory with mutable data: race conditions, deadlocks, livelocks, and so on.</description>
    </item>
    <item>
      <title>Relational Database Management Systems</title>
      <link>http://localhost:1313/posts/relational-database-management-systems/</link>
      <pubDate>Thu, 19 Sep 2024 00:00:00 -0700</pubDate>
      <guid>http://localhost:1313/posts/relational-database-management-systems/</guid>
      <description>If your application needs to handle a large, long-lived set of interrelated data elements, you can confidently place it in a relational database. In the past, there were few relational DBMSs; they were complex, expensive to maintain, and clunky beasts. Those times are gone. Today, finding a relational DBMS is not difficult: it is quite possible that a relational DBMS or even two are already installed on your machine. Some very advanced relational DBMSs, such like MySQL and PostgreSQL, are available in source code, so the question of costs it is no longer worth buying them. Moreover, the so-called &amp;ldquo;embedded database systems&amp;rdquo; can be integrated into your application as libraries, almost requiring no configuration and administration; two such examples are interesting open-source DBMS, SQLite and HSQLDB.</description>
    </item>
  </channel>
</rss>
