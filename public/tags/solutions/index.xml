<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Solutions on Tiny Dev Blog</title>
    <link>http://localhost:1313/tags/solutions/</link>
    <description>Recent content in Solutions on Tiny Dev Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 04 Aug 2024 00:00:00 -0700</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/solutions/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Reduce the intrinsic complexity and eliminate the incidental complexity</title>
      <link>http://localhost:1313/posts/reduce-the-intrinsic-complexity-and-eliminate-the-incidental-complexity/</link>
      <pubDate>Sun, 04 Aug 2024 00:00:00 -0700</pubDate>
      <guid>http://localhost:1313/posts/reduce-the-intrinsic-complexity-and-eliminate-the-incidental-complexity/</guid>
      <description>Essential complexity is a problem inherent in any task. For example, the task of coordinating air traffic at the national level is complex in itself. The control system must monitor in real time the precise location of each aircraft (including altitude), its speed, direction and destination, in order to prevent collisions in the air and on the runways. It is also necessary to manage flight schedules promptly to avoid congestion at airports in constantly changing conditions – when the weather changes sharply the entire schedule has to be revised.&#xA;On the other hand, accidental complexity is caused by challenges that we think need to be solved in order to reduce the inherent complexity. An example of a minor complexity is the outdated flight management system still in use.</description>
    </item>
    <item>
      <title>Простота лучше универсальности</title>
      <link>http://localhost:1313/posts/%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D1%82%D0%B0-%D0%BB%D1%83%D1%87%D1%88%D0%B5-%D1%83%D0%BD%D0%B8%D0%B2%D0%B5%D1%80%D1%81%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B8/</link>
      <pubDate>Mon, 20 May 2024 00:00:00 -0700</pubDate>
      <guid>http://localhost:1313/posts/%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D1%82%D0%B0-%D0%BB%D1%83%D1%87%D1%88%D0%B5-%D1%83%D0%BD%D0%B8%D0%B2%D0%B5%D1%80%D1%81%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B8/</guid>
      <description>A typical problem with many frameworks, class libraries, basic services and other infrastructure code is that they are designed for universal use, without attachment to specific applications. As a result, we get a staggering set of features and settings that are often not used at all or used for the wrong purpose, or even simply turned out to be useless.Most developers work on specific systems, and the pursuit of unlimited versatility rarely serves them well.The best way to universality lies through an in-depth understanding of known concrete examples and analysis of their essence in order to find a fundamental common solution: simplicity as a result of practical experience, rather than universality based on conjecture.&#xA;The priority of simplicity over versatility helps to make a choice between two architectural alternatives, equal in other respects.</description>
    </item>
  </channel>
</rss>
