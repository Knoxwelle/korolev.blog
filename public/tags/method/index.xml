<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Method on Korolev Blog</title>
    <link>http://localhost:1313/tags/method/</link>
    <description>Recent content in Method on Korolev Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 10 Dec 2024 00:00:00 -0700</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/method/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Tests are written for people</title>
      <link>http://localhost:1313/posts/tests-are-written-for-people/</link>
      <pubDate>Tue, 10 Dec 2024 00:00:00 -0700</pubDate>
      <guid>http://localhost:1313/posts/tests-are-written-for-people/</guid>
      <description>You cover all the finished code or its fragments with automated tests. Congratulations! Do you write tests first and then code? Even better! Just because of this, you can be considered a programmer practicing advanced approaches in software development. But are your tests good? How can you determine that? One way is to ask yourself: &amp;ldquo;Who am I writing for?&amp;rdquo; these tests?Â». If the answer is &amp;ldquo;I write them for myself to reduce costs for debugging&amp;rdquo; or &amp;ldquo;for the compiler to execute them,&amp;rdquo; then it&amp;rsquo;s quite possible that you are not writing the best tests. So, for whom Why write tests? For those who will try to understand your code.&#xA;Good tests serve as documentation for the code they are testing. They describe how the code works.</description>
    </item>
    <item>
      <title>Convenience is not an attribute of quality</title>
      <link>http://localhost:1313/posts/convenience-is-not-an-attribute-of-quality/</link>
      <pubDate>Tue, 16 Jul 2024 00:00:00 -0700</pubDate>
      <guid>http://localhost:1313/posts/convenience-is-not-an-attribute-of-quality/</guid>
      <description>Much has been said about the importance and complexity of designing good APIs (application programming interfaces). It&amp;rsquo;s hard to get everything right the first time, and even harder to change anything along the way; it&amp;rsquo;s like raising children. Experienced programmers have already understood that a good API offers the same level of abstraction for all methods, possesses uniformity and symmetry, and forms a vocabulary for an expressive language. Unfortunately, knowing the principles is one thing, but following them in practice is another. You know that eating sweets is harmful.&#xA;But let&amp;rsquo;s move from words to action and analyze a specific &amp;ldquo;strategy&amp;rdquo; for API design that I encounter constantly: designing the API to be user-friendly. As a rule, it all starts with one of the following &amp;ldquo;insights&amp;rdquo;:</description>
    </item>
  </channel>
</rss>
