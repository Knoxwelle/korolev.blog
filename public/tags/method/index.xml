<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Method on Korolev Blog</title>
    <link>http://localhost:1313/tags/method/</link>
    <description>Recent content in Method on Korolev Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 23 Nov 2024 00:00:00 -0700</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/method/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>The golden rule of API design</title>
      <link>http://localhost:1313/posts/the-golden-rule-of-api-design/</link>
      <pubDate>Sat, 23 Nov 2024 00:00:00 -0700</pubDate>
      <guid>http://localhost:1313/posts/the-golden-rule-of-api-design/</guid>
      <description>Designing application programming interfaces (APIs) is difficult, especially in the general case. When developing an API that will have hundreds or thousands of users, you need to consider that over time it will most likely need to be changed, and these changes can disrupt the functioning of the client code. Moreover, you need to consider the potential impact on your API from its users. If the API class calls its own method, it should be remembered that the user is capable of creating a subclass of your class and overriding this method, which can lead to disaster. And you won&amp;rsquo;t be able to change this method because some of your users have given it a different meaning. You become dependent on your users when it comes to choosing the internal implementation.</description>
    </item>
    <item>
      <title>Tests are written for people</title>
      <link>http://localhost:1313/posts/tests-are-written-for-people/</link>
      <pubDate>Thu, 24 Oct 2024 00:00:00 -0700</pubDate>
      <guid>http://localhost:1313/posts/tests-are-written-for-people/</guid>
      <description>You cover all the finished code or its fragments with automated tests. Congratulations! Do you write tests first and then code? Even better! Just because of this, you can be considered a programmer practicing advanced approaches in software development. But are your tests good? How can you determine that? One way is to ask yourself: &amp;ldquo;Who am I writing for?&amp;rdquo; these tests?». If the answer is &amp;ldquo;I write them for myself to reduce costs for debugging&amp;rdquo; or &amp;ldquo;for the compiler to execute them,&amp;rdquo; then it&amp;rsquo;s quite possible that you are not writing the best tests. So, for whom Why write tests? For those who will try to understand your code.&#xA;Good tests serve as documentation for the code they are testing. They describe how the code works.</description>
    </item>
    <item>
      <title>Convenience is not an attribute of quality</title>
      <link>http://localhost:1313/posts/convenience-is-not-an-attribute-of-quality/</link>
      <pubDate>Thu, 17 Oct 2024 00:00:00 -0700</pubDate>
      <guid>http://localhost:1313/posts/convenience-is-not-an-attribute-of-quality/</guid>
      <description>Much has been said about the importance and complexity of designing good APIs (application programming interfaces). It&amp;rsquo;s hard to get everything right the first time, and even harder to change anything along the way; it&amp;rsquo;s like raising children. Experienced programmers have already understood that a good API offers the same level of abstraction for all methods, possesses uniformity and symmetry, and forms a vocabulary for an expressive language. Unfortunately, knowing the principles is one thing, but following them in practice is another. You know that eating sweets is harmful.&#xA;But let&amp;rsquo;s move from words to action and analyze a specific &amp;ldquo;strategy&amp;rdquo; for API design that I encounter constantly: designing the API to be user-friendly. As a rule, it all starts with one of the following &amp;ldquo;insights&amp;rdquo;:</description>
    </item>
    <item>
      <title>Know your IDE</title>
      <link>http://localhost:1313/posts/know-your-ide/</link>
      <pubDate>Wed, 13 Mar 2024 00:00:00 -0700</pubDate>
      <guid>http://localhost:1313/posts/know-your-ide/</guid>
      <description>In the 1980s, the programming environment, as a rule, did not differ much from an advanced text editor – at best. Today, we take syntax highlighting for granted, but back then it was a luxury not available to everyone. Code formatting tools existed as external tools, the use of which corrected spacing. Debuggers also &amp;ldquo;lived&amp;rdquo; separately as programs for step-by-step code execution, and working with them required knowing a multitude of mysterious key combinations.&#xA;In the 1990s, companies began to realize the profit potential of more convenient and useful development tools. The Integrated Development Environment (IDE) combined previously offered editing features with a compiler, debugger, formatting tools, and other instruments. At that time, menus and mice became popular, which meant that developers no longer needed to memorize complex key combinations to work with their editor.</description>
    </item>
  </channel>
</rss>
