<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Korolev Blog</title>
    <link>http://localhost:1313/categories/java/</link>
    <description>Recent content in Java on Korolev Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 08 May 2025 00:00:00 -0700</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Message passing improves the scalability of parallel systems</title>
      <link>http://localhost:1313/posts/message-passing-improves-the-scalability-of-parallel-systems/</link>
      <pubDate>Thu, 08 May 2025 00:00:00 -0700</pubDate>
      <guid>http://localhost:1313/posts/message-passing-improves-the-scalability-of-parallel-systems/</guid>
      <description>Already in the first lectures on computer science, programmers are taught that concurrent computing – and especially parallel computing as a special subtype of concurrent computing – is a difficult task, and that only the best have a hope of coping with it, and that even the best do not manage to do so. Great attention is invariably paid to threads, semaphores, monitors, and the difficulties of organizing thread safety with simultaneous access to variables.&#xA;There are indeed many complex problems here, and solving them can be very difficult. But what is the root of the problems? Shared memory. Almost all the problems of concurrent computing that we constantly hear about are related to shared memory with mutable data: race conditions, deadlocks, livelocks, and so on.</description>
    </item>
    <item>
      <title>Know your IDE</title>
      <link>http://localhost:1313/posts/know-your-ide/</link>
      <pubDate>Sun, 27 Apr 2025 00:00:00 -0700</pubDate>
      <guid>http://localhost:1313/posts/know-your-ide/</guid>
      <description>In the 1980s, the programming environment, as a rule, did not differ much from an advanced text editor – at best. Today, we take syntax highlighting for granted, but back then it was a luxury not available to everyone. Code formatting tools existed as external tools, the use of which corrected spacing. Debuggers also &amp;ldquo;lived&amp;rdquo; separately as programs for step-by-step code execution, and working with them required knowing a multitude of mysterious key combinations.&#xA;In the 1990s, companies began to realize the profit potential of more convenient and useful development tools. The Integrated Development Environment (IDE) combined previously offered editing features with a compiler, debugger, formatting tools, and other instruments. At that time, menus and mice became popular, which meant that developers no longer needed to memorize complex key combinations to work with their editor.</description>
    </item>
    <item>
      <title>The drama of hype technologies, customer needs, and pangs of conscience</title>
      <link>http://localhost:1313/posts/the-drama-of-hype-technologies-customer-needs-and-pangs-of-conscience/</link>
      <pubDate>Tue, 22 Oct 2024 00:00:00 -0700</pubDate>
      <guid>http://localhost:1313/posts/the-drama-of-hype-technologies-customer-needs-and-pangs-of-conscience/</guid>
      <description>We, programmers, sometimes choose to use certain technologies, methodologies, and approaches to problem-solving not because they provide the optimal solution, but simply because deep down, we want to mention them in our resumes. Such a choice very rarely leads to a positive result.&#xA;The most powerful catalyst for any career will be grateful clients lining up in long queues to recommend you to others – after all, you worked so hard for them. If this is true, it&amp;rsquo;s strange that they let you go. Client goodwill It will serve you much better than any trendy object of a trendy language and any trendy paradigm. Although it is very important (and even vital) for a software architect to stay updated on the latest trends and technologies, never try to broaden your horizons at the expense of the client.</description>
    </item>
    <item>
      <title>The assembly must be clean</title>
      <link>http://localhost:1313/posts/the-assembly-must-be-clean/</link>
      <pubDate>Thu, 19 Sep 2024 00:00:00 -0700</pubDate>
      <guid>http://localhost:1313/posts/the-assembly-must-be-clean/</guid>
      <description>Have you ever seen a list of compiler warnings the size of an essay on how not to write code and thought: &amp;ldquo;Of course, something needs to be done about this&amp;hellip; but I just don&amp;rsquo;t have time for it right now&amp;rdquo;? And conversely, have you ever seen a single warning appear during compilation and immediately fix it?&#xA;When I start a new project from scratch, there are no warnings, no mess, no problems. But as the codebase grows, if no measures are taken, it&amp;rsquo;s likely that the mess, clutter, warnings, and issues will gradually accumulate. In a large stream of &amp;ldquo;noise,&amp;rdquo; it becomes significantly harder to find a truly important warning among the hundreds of others that I am not interested in.&#xA;To make warnings useful again, I try to adhere to a policy of zero tolerance for warnings during assembly.</description>
    </item>
    <item>
      <title>Relational Database Management Systems</title>
      <link>http://localhost:1313/posts/relational-database-management-systems/</link>
      <pubDate>Sun, 25 Aug 2024 00:00:00 -0700</pubDate>
      <guid>http://localhost:1313/posts/relational-database-management-systems/</guid>
      <description>If your application needs to handle a large, long-lived set of interrelated data elements, you can confidently place it in a relational database. In the past, there were few relational DBMSs; they were complex, expensive to maintain, and clunky beasts. Those times are gone. Today, finding a relational DBMS is not difficult: it is quite possible that a relational DBMS or even two are already installed on your machine. Some very advanced relational DBMSs, such like MySQL and PostgreSQL, are available in source code, so the question of costs it is no longer worth buying them. Moreover, the so-called &amp;ldquo;embedded database systems&amp;rdquo; can be integrated into your application as libraries, almost requiring no configuration and administration; two such examples are interesting open-source DBMS, SQLite and HSQLDB.</description>
    </item>
    <item>
      <title>The golden rule of API design</title>
      <link>http://localhost:1313/posts/the-golden-rule-of-api-design/</link>
      <pubDate>Mon, 29 Jul 2024 00:00:00 -0700</pubDate>
      <guid>http://localhost:1313/posts/the-golden-rule-of-api-design/</guid>
      <description>Designing application programming interfaces (APIs) is difficult, especially in the general case. When developing an API that will have hundreds or thousands of users, you need to consider that over time it will most likely need to be changed, and these changes can disrupt the functioning of the client code. Moreover, you need to consider the potential impact on your API from its users. If the API class calls its own method, it should be remembered that the user is capable of creating a subclass of your class and overriding this method, which can lead to disaster. And you won&amp;rsquo;t be able to change this method because some of your users have given it a different meaning. You become dependent on your users when it comes to choosing the internal implementation.</description>
    </item>
  </channel>
</rss>
