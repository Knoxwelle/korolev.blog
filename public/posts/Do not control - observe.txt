+++
title = 'Do not control - observe'
date = 2024-05-31T00:00:00-07:00
draft = false
categories = []
tags = ["modern", "eric dorenburg", "system", "model", "architecture", "messages", "channels"]
cover_image='/images/cover/knoxwelle__2020-04-25T085731.000Z.jpg'
+++
Modern systems are distributed and loosely coupled.The construction of loosely connected systems creates quite a few troubles, so why do we go for it?Because we want our systems to be flexible and not fall apart at the slightest changes.This is a critical property in modern environments, where we control only a small part of our application, while everything else exists in the form of distributed services or packages that are managed by other departments or external vendors.

So, the desire to create a system that is flexible and capable of evolving over time is a good thing.But this also means that our system will gradually change.In other words, "today the system is no longer what it was yesterday."Unfortunately, this noticeably complicates the documentation of the system.Everyone knows that documentation becomes outdated the moment it is printed, but in a constantly changing system, things can be even worse.Moreover, building a flexible system usually complicates the architecture, making it even harder to obtain the so-called "big picture."For example, if all the components of the system exchange information through logical, configurable channels, then to gain an understanding of what is happening, it is necessary to look at the configuration of the channels.Sending messages to a logical "I-don't-know-where" is unlikely to lead to a compilation error, but it will surely disappoint the user whose action was wrapped in this message.

An architect obsessed with total control is a figure from the past; the solutions he creates are highly interconnected and fragile.On the other hand, complete and unrestricted freedom of application is a sure path to chaos.The easing of control needs to be supplemented with other mechanisms so that "flying by instruments" does not occur without the instruments themselves.But what instruments do we have at our disposal?Actually, there are more than enough of them. Modern programming languages support reflection, and almost all platforms provide dynamic runtime metrics.As the system becomes more customizable, its current configuration itself becomes an excellent source of information.Since it is quite difficult to make sense of an excessively large volume of low-level data, create a model based on them.For example, when it becomes clear which components send messages through certain logical channels and which components expect to receive messages through these channels, you will be able to construct a graph of data transmission between the components. This procedure can be carried out every few minutes or hours, creating an accurate and timely picture of the system as it develops.Consider this your kind of "reverse MDA."Instead of a model that governs the architecture, you build a flexible architecture and shape the model based on the current state of the system.

In many cases, the model can be easily visualized by creating a truly "big picture."However, resist the temptation to fill the 3 × 5 meter canvas with squares and lines in an attempt to depict all the classes of your system.Such a painting could pass for a work of contemporary art, but it cannot be called a useful program model.Instead, it is better to use "a view from 300 meters high," as recommended by Eric Dorenburg – that level of abstraction contains truly useful information.Additionally, you will be able to ensure that the model does not violate basic rules of correctness—such as cyclic references in the dependency graph or sending messages through unmonitored logical channels.

The weakening of control is frightening, especially when it comes to the architecture of the system.But in combination with careful observation, model building, and correctness verification, it is likely the only reasonable approach to software architecture in the 21st century.